import socket
import tkinter as tk
import threading

def scan_ports():
    target_ip = ip_entry.get()  # Obtiene la IP ingresada desde la interfaz

    # Escaneo de puertos con concurrencia
    open_ports = []
    threads = []
    for port in range(1, 65536):
        thread = threading.Thread(target=scan_port, args=(target_ip, port, open_ports))
        thread.start()
        threads.append(thread)

    # Espera a que todos los hilos finalicen
    for thread in threads:
        thread.join()

    # Mostrar puertos abiertos en una nueva interfaz
    show_open_ports(open_ports)

def scan_port(target_ip, port, open_ports):
    # Resto del código de la función scan_port aquí
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(1)  # Definimos un tiempo límite de 1 segundo para la conexión

    try:
        # Intentamos conectarnos al puerto del objetivo
        result = sock.connect_ex((target_ip, port))
        if result == 0:
            open_ports.append(port)

    except socket.error:
        pass

    finally:
        # Cerramos la conexión del socket
        sock.close()

def show_open_ports(open_ports):
    # Interfaz para mostrar los puertos abiertos
    window = tk.Tk()
    window.title("Puertos Abiertos")
    window.geometry("300x150")

    ports_label = tk.Label(window, text="Puertos Abiertos:")
    ports_label.pack()

    ports_text = tk.Text(window, height=10, width=30)
    ports_text.pack()

    for port in open_ports:
        ports_text.insert(tk.END, f"Puerto {port}\n")

    window.mainloop()

# Interfaz para ingresar la IP del objetivo
ip_window = tk.Tk()
ip_window.title("Ingresar IP del Objetivo")
ip_window.geometry("300x100")

ip_label = tk.Label(ip_window, text="IP del objetivo o URL:")
ip_label.pack()

ip_entry = tk.Entry(ip_window)
ip_entry.pack()

scan_button = tk.Button(ip_window, text="Escanear", command=scan_ports)
scan_button.pack()

ip_window.mainloop()
